# 递归

递归是一种函数调用自己的编程技巧。递归的基本思想是将一个复杂的问题分解为更简单的子问题，直到子问题的规模足够小，能够直接解决。递归通常由两个部分组成：

- 终止条件：递归的终止条件，防止无限递归。
- 递归调用：将当前问题转化为更小规模的同类问题，并在其上进行求解

## 递归的典型使用场景

1. 数学递推 / 序列

- 斐波那契、阶乘、整数拆分、快速幂。

- 要点：极易爆炸式增长，通常配合记忆化或改写为迭代。

2. 分治（Divide & Conquer）

- 归并排序、快速排序、二分搜索、矩阵分块、区间问题。

- 要点：把大问题拆成若干等结构小问题，合并子问题答案。

3. 树 / 图的遍历与计算

- 二叉树路径和、深度/直径、最近公共祖先；图的 DFS、连通块计数。

- 要点：节点的结果往往由左右子树（或相邻节点）结果合并而来。

4. 回溯（Backtracking）

- 排列组合、子集问题、N 皇后、数独、括号生成、路径枚举。

- 要点：在递归过程中做选择→递归→撤销选择（回退）。

5. 记忆化搜索（递归 + 缓存）

- 网格走法计数、最短/最小代价、带状态的路径计数（如“在最多 k 步内到达”）。

- 要点：状态通常由“位置 + 剩余资源（步数/容量/面具等）”构成。

6. 结构型数据的递归定义

- 反转链表（递归版）、表达式解析（语法树）、目录树遍历。

- 要点：数据本身天然递归（树/嵌套结构），用递归描述最自然。

## 构造思路（递归“万能五步”）

1. 明确状态：用最少的参数刻画子问题（如坐标、索引、剩余步数）。

2. 终止条件：最小规模直接返回（越早越好）。

3. 递归拆分：把当前问题转化为若干更小的同类问题。

4. 合并结果：max/sum/min/布尔或自定义合并逻辑。

7. 单调推进：每次递归“更接近”终止（索引移动、步数减少、规模缩小）。

额外：

- 若有重叠子问题 → 加记忆化（functools.lru_cache）。

- 回溯题要“做选择→递归→撤销选择”。

- 注意 Python 无尾递归优化，深度过深考虑改迭代或手动栈。