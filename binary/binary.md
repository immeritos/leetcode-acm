# 1.二分知识讲解

二分算法是一种高效的查找算法，适用于已经排好序的数组或集合。其基本思想是通过每次将待查找的区间分成两半来逐步缩小查找范围，从而快速定位目标元素。与线性查找不同，二分查找能够大大减少查找次数，时间复杂度为O(log n)，其中n为数组的长度。

# 2. 二分查找的基本原理

前提条件：二分法的数据必须满足单调性:
- 这是因为二分法的核心思想是通过比较目标值和中间值来决定下一步搜索的区间。如果数据不是单调的，那么我们无法保证每次通过中间值进行判断后，能够缩小问题的范围，从而导致无法正确找到目标值。

具体来说，二分算法依赖于以下几个关键步骤：

- 中间值的选择：每次通过选择区间的中间值，将搜索范围一分为二。
- 比较与判断：通过将目标值与中间值进行比较，判断目标值应该位于左侧还是右侧。
- 区间缩小：根据比较结果，将查找范围缩小到目标值可能存在的半区间。

如果数据是单调递增的，意味着任何一个位置的值都比它前面的值大。这样我们就可以通过比较目标值与中间值来决定是往左还是往右缩小区间。相反，如果数据不是单调递增或递减的，那么目标值可能出现在区间的任何位置，二分算法就无法有效地通过比较来缩小查找范围，导致无法正确查找。

# 3. 二分查找过程：

- 设定一个查找范围的左右边界，通常用两个变量表示，low 和 high。
- 计算当前区间的中间元素：mid = (low + high) / 2
- 将中间元素与目标值进行比较：
    - 如果中间元素等于目标值，查找成功，返回该元素的位置。
    - 如果中间元素大于目标值，说明目标值在左半部分，更新high = mid - 1。
    - 如果中间元素小于目标值，说明目标值在右半部分，更新low = mid + 1。
- 重复上述过程，直到查找范围为空（low > high），即目标值不存在。

# 4. 时间复杂度：
二分查找的时间复杂度是 $O(log n)$，每次查找都将查找范围缩小一半。因此，二分查找的效率远高于线性查找（$O(n)$）。

# 5. 适用场景：

- 适用于有序的数组、链表、集合等数据结构。
- 也可以用在一些需要判断特定条件是否成立的问题中，比如求解最小值、最大值、满足某种性质的边界等。

# 6. 思路：
1. 确定二分查找的范围
二分查找的查找范围就是整个数组的区间，即数组的下标从 0 到 A.size() - 1。我们将 low 设置为 0，high 设置为数组的最后一个下标。
```python
left = 0
right = len(A) - 1
```
2. 计算中间元素
每次进行二分查找时，我们需要计算当前查找区间的中间元素 mid，并将其与目标值进行比较。为了防止溢出，我们用 mid = (left + right) // 2 来计算。
```python
mid = (left + right) // 2  # 计算中间元素
```
3. 判断中间元素与目标值的关系

- 如果 A[mid] == x，说明我们找到了目标值，返回 True。
- 如果 A[mid] < x，说明目标值可能在右半部分，更新左边界 left = mid + 1。
- 如果 A[mid] > x，说明目标值可能在左半部分，更新右边界 right = mid - 1。

```python
if A[mid] == x:
    return True  # 找到目标值
elif A[mid] < x:
    left = mid + 1  # 目标值在右半部分
else:
    right = mid - 1  # 目标值在左半部分
```
4. 终止条件
当查找区间为空（即 left > right），说明目标值不存在，返回 False。
```python
return False  # 没有找到目标值
```
# 7. Python 中的 bisect_left 和 bisect_right
Python 提供了 bisect 模块，它包含了类似 C++ 中 lower_bound 和 upper_bound 函数的功能。
## 7.1. bisect_left 函数
bisect_left 函数返回目标值不小于目标值的位置索引。简言之，它返回数组中第一个不小于指定值的元素的位置。如果指定值已经存在，返回该元素第一次出现的位置。
```python
import bisect
arr = [1, 3, 3, 5, 7]
position = bisect.bisect_left(arr, 3)
print(position)  # 输出 1
```
## 7.2. bisect_right 函数
bisect_right 函数返回目标值大于目标值的位置索引。如果指定值已经存在，它返回该值最后一次出现后的下一个位置。
```python
import bisect
arr = [1, 3, 3, 5, 7]
position = bisect.bisect_right(arr, 3)
print(position)  # 输出 3
```
## 7.3 主要区别

- bisect_left：查找目标值的第一个不小于目标值的位置。
- bisect_right：查找目标值的第一个大于目标值的位置。

```python
```